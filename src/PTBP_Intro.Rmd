---
title: 'The Pediatric Template of Brain Perfusion: Quick introduction'
author: "Brian B. Avants et al."
date: "May 7, 2015"
output:
  beamer_presentation:
    colortheme: dolphin
    fonttheme: structurebold
    highlight: tango
    incremental: yes
    theme: AnnArbor
    includes:
      in_header: mystyle.tex
    toc: yes
--- 

# Overview and resources

## Overview 

The Pediatric Template of Brain Perfusion (PTBP) [at figshare](http://figshare.com/articles/The_Pediatric_Template_of_Brain_Perfusion_PTBP_/923555).

- Free multiple modality MRI data with demographics and psychometrics
- Collected to aid as a reference for normal variability in structure and cerebral blood flow during adolescence
- The data is accompanied by an [organized csv file](http://files.figshare.com/1699436/ptbp_summary_demographics.csv) 
- The full data is available at [figshare](http://figshare.com/articles/The_Pediatric_Template_of_Brain_Perfusion_PTBP_/923555)
- Here we use a slightly processed version of the data
- Each subject contains a slab version of T1, FA, B0, CBF, Thickness, Segmentation and AAL in subject space
- There is also a template contained in the download.

## Download the processed data

\Large

- Download
- <https://www.dropbox.com/s/u8bg5z5k6do56om/ants_tutorial_data.zip?dl=0>
- Move this to your ANTsTutorial directory.
- Unzip the file in the ANTsTutorial directory.

## If you have not already, download [*ANTsR*](http://stnava.github.io/ANTsR/)

* Get *R* from [OSX *R*](http://cran.r-project.org/bin/macosx/) or 
  [Linux *R*](http://www.jason-french.com/blog/2013/03/11/installing-r-in-linux/), 
  optionally [*RStudio*](http://www.rstudio.com/products/rstudio/download/)
* Install *ANTsR* dependencies
```r
pkgmin=c("magrittr","Rcpp") # core dependencies
pkgxtra=c("igraph","randomForest","misc3d","rgl",
  "mFilter","fastICA","fpc","knitr","rmarkdown",
  "pixmap","png","signal","visreg")
install.packages( c( pkgmin, pkgxtra ) ) 
```
* Download the *ANTsR* tar.gz to `filename.tar.gz`
* Install via command line (or *RStudio* `tools` $\rightarrow$ `install`): 
```bash
   R CMD INSTALL filename.tar.gz
```
* Test via ( in `R` ) calling: 
```r
  library(ANTsR)
```
* Done!

# Quick Look 

## Get the demographics file

```{r csv}
library(ANTsR)
bd="/Users/stnava/data/ANTsTutorial/"
csvlink="http://files.figshare.com/1699436/ptbp_summary_demographics.csv"
tfn=tempfile(fileext='.csv')
demog = read.csv( paste( bd, "data/ptbp_summary_demographics.csv", sep='' ) )
if ( ! exists("demog") )
  {
  demog=download.file(csvlink,tfn)
  if ( demog == 0 ) demog=read.csv( tfn )
  }
```

## Investigate the demographics

```{r demog}
str(demog[,1:10])
```

## Investigate the demographics

```{r demog2}
str(demog[,11:20])
```

# Review multiple modality images

## Read the structural PTBP template image

```{r readstruct, echo=TRUE}
t1fn = paste(bd,
  "./data/template/PTBP_T1_BrainCerebellum.nii.gz",
  sep='')
t1tem = antsImageRead( t1fn )
```

## Plot the structural PTBP template image

```{r plotstruct, echo=FALSE, warning=FALSE}
plot(t1tem,dorot=1,slices=8)
```

## Plot the CBF PTBP template image

```{r plotcbf, echo=FALSE, warning=FALSE}
cbftem = paste(bd,"./data/template/PTBP_CBF.nii.gz",sep='')
cbftem = antsImageRead( cbftem )
plot(cbftem,dorot=1,slices=8)
```

## Find subject image

```{r substruct, echo=TRUE}
subnum=11
id=demog$SubID[subnum]
dt=demog$ScanDate[subnum]
exts=c( "mprage_t1.nii.gz" , 
        "fa_anatomical.nii.gz", 
        "MeanCBFWarpedToT1.nii.gz", 
        "CorticalThickness.nii.gz", 
        "BrainSegmentation.nii.gz", 
        "AAL.nii.gz" )
pre=paste( bd,"data/Subjects/",id,"/",dt,"/*",sep='')
fns=Sys.glob( paste( pre, exts , sep='') )
```

## Review each modality
```{r mod1, echo=FALSE}
plot( antsImageRead( fns[1] ), dorot=1, slices=8)
```

## Review each modality 
```{r mod2, echo=FALSE}
plot( antsImageRead( fns[2] ), dorot=1, slices=8)
```

## Review each modality 
```{r mod3, echo=FALSE}
plot( antsImageRead( fns[3] ), dorot=1, slices=8)
```

## Review each modality 
```{r mod4, echo=FALSE}
plot( antsImageRead( fns[4] ), dorot=1, slices=8)
```

## Review each modality 
```{r mod5, echo=FALSE}
plot( antsImageRead( fns[5] ), dorot=1, slices=8)
```

## Review each modality 
```{r mod5b, echo=FALSE}
cseg=antsImageRead( fns[5] ) %>% thresholdImage(2,2)
plot( antsImageRead( fns[1] ), cseg, dorot=1, slices=8)
```

## Review each modality 
```{r mod6, echo=FALSE}
aal=antsImageRead( fns[6] )
plot( antsImageRead( fns[1] ), aal, dorot=1, slices=8, 
      window.overlay=c( 1, max(aal) ) )
```

## Review each modality 
```{r mod1b, echo=FALSE}
fa=antsImageRead( fns[2] ) %>% iMath("Canny")
plot( antsImageRead( fns[1] ), fa, dorot=1, slices=8 )
```

## Count complete subject images

```{r ctsubimages, echo=TRUE}
havecompletesubject=rep(FALSE,nrow(demog))
for ( x in 1:nrow(demog) )
  {
  id = demog$SubID[x]
  dt = demog$ScanDate[x]
  pre = paste( bd,"data/Subjects/",id,"/",dt,"/*",sep='')
  fns = Sys.glob( paste( pre, exts , sep='') )
  if ( length( fns ) == 6 ) havecompletesubject[x]=TRUE
  }
nsub=sum( havecompletesubject  )
```

## PTBP in our tutorial

We have `r nsub` multiple modality subjects to process
and to analyze.

We will use them to:

* Build a template

* Construct template priors with [joint label fusion](http://www.ncbi.nlm.nih.gov/pubmed/22732662)

* Normalize, segment, compute thickness

* Map other modalities to structural reference

* Investigate [Eigenanatomy](https://scholar.google.com/scholar?hl=en&q=Eigenanatomy&btnG=&as_sdt=1%2C5&as_sdtp=) and [SCCAN](https://scholar.google.com/scholar?q=sparse+canonical+correlation+avants&btnG=&hl=en&as_sdt=0%2C5) for relating demographic and psychometric measurements to the imaging and ...

* relating imaging modalities to each other.

* Finally, put all this together to create a reproducible analysis document for the PTBP.


# Templates and joint label fusion

## We built a template, now what?

* Suppose a dataset that already contains segmentations.

* Transform these segmentations to the template.

* Perform a weighted voting to customize the segmentations for the template.

## Template priors with SyN-Quick

```{r maptem, echo=TRUE, eval=FALSE, warning=FALSE}
# t1tem read before
ilist=list()
seglist=list()
for ( x in which( havecompletesubject )[1:60] )
  {
  id = demog$SubID[x]
  dt = demog$ScanDate[x]
  pre = paste( bd,"data/Subjects/",id,"/",dt,"/*",sep='')
  fns = Sys.glob( paste( pre, exts , sep='') )
  t1 = antsImageRead( fns[1] )
  mytx = antsRegistration( t1tem, t1, "SyN" )
  seg = antsImageRead( fns[5] )
  segw = antsApplyTransforms( t1tem, seg, mytx$fwd, interpolator="NearestNeighbor"  )
  ilist = lappend( ilist, mytx$warpedmovout )
  seglist = lappend( seglist, segw )
  }
```

## Template, intensity images, segmentations $\rightarrow$ JLF

* Joint label fusion is a multi-atlas segmentation method.

* It performed well in several recent competitions ([SATA 2012, SATA 2013](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3837555/))

* We use it regularly in our studies to build template priors and to label cortical or deep structures in the brain.

## JLF theory: "Multi-Atlas Segmentation with Joint Label Fusion"

A matrix $M_x$ is defined by the number of atlas segmentations one has.

$M_x(i,j)$ measures joint atlas errors wrt a target segmentation at a voxel.

Entries in $M_x$ relate to the likelihood two atlases make the same error.

> The key difference between joint label fusion and other label fusion methods is that it explicitly considers correlations among atlases, i.e., the dependence matrix, into voting weight assignment to reduce bias in the atlas set.

## JLF theory: "Multi-Atlas Segmentation with Joint Label Fusion"

The expected label difference between the consensus solution obtained from weighted voting and the target segmentation is: $w_x^T M_x w_x$.

Find atlas weights, $w_x$, for each of $A^i$ atlases, st
$$ w_x^T ( M_x + \alpha \text{Id} ) w_x $$ 
is minimized subject to $\sum_{i=1}^n w_x(i)=1$.

## JLF theory: "Multi-Atlas Segmentation with Joint Label Fusion"

Define 
$$ K_m = \langle |~A^{i,m}_N - T^{m}_N~|, |~A^{j,m}_N - T^{m}_N~| \rangle $$
then
$$ M_x(i,j) =  ( \sum_m K_m )^\beta $$
with $N$ representing a neighborhood calculation, $A^{i,m}$ representing the $i^\text{th}$ atlas and the $m^\text{th}$ modality. Lagrange multipliers yield:
$$w_x=\frac{M_x^{-1} 1_n}{1_n^t M_x^{-1} 1_n}$$

Finally, local patch search is used to improve the neighborhoods that correspond.

## JLF Example

Suppose that a pair of atlases $A_1$ and $A_2$ produce statistically independent label errors for a given target image. If $A_1$ produces a wrong label 50\% of the time and $A_2$ produces a wrong label 20\% of the time, we have
$$
M_x = \begin{bmatrix}
    0.5       & 0.1 \\
    0.1       & 0.2 
\end{bmatrix}
$$
The optimal voting weights are then $w_x = [0.2, 0.8]^t.$

## Template [Joint Label/Intensity Fusion](http://journal.frontiersin.org/article/10.3389/fninf.2013.00027/abstract)

```{r jlftem, echo=TRUE, eval=FALSE, warning=FALSE }
mk=getMask(t1tem)
jlf=jointIntensityFusion( t1tem, mk, ilist, 
  labelList=seglist, rad=rep(2,3), rSearch=2, 
  computeProbs=TRUE, includezero=TRUE)
# write out results
if ( ! exists("tf") ) tf=tempfile() 
antsImageWrite( jlf$segimg, paste(tf,'seg.nii.gz',sep='') )
antsImageWrite( jlf$predimg, paste(tf,'pred.nii.gz',sep='') )
for ( i in 1:length(jlf$probimgs) )
  antsImageWrite( jlf$probimgs[[i]], 
                  paste(tf,'prob',i,'.nii.gz',sep='') )
```

## Augment CSF probability

```{r temper,eval=TRUE,results='hide',warning=FALSE,echo=FALSE}
if ( ! exists("jlf") ) {
setwd("/Users/stnava/data/ANTsTutorial/")
tf="data/JLF_out/jlfout_"
kk=Sys.glob( paste(tf,"prob*nii.gz",sep='') )
segfn=paste( tf,"seg.nii.gz", sep='') 
jlf=list( segimg=antsImageRead(segfn),
  probimgs=imageFileNames2ImageList( kk  ) )
}
```

```{r kmeanstemplate1,eval=TRUE}
if ( !exists("mk") ) mk=getMask(t1tem)
ktem=kmeansSegmentation(t1tem,3,mk)
jlcsf=jlf$probimgs[[1]][ mk==1 ]
kmcsf=ktem$probabilityimages[[1]][ mk==1 ]
csfmat=rbind( jlcsf, kmcsf )
newcsfvec = apply( csfmat, MARGIN=2, FUN=max )
newcsf=makeImage( mk, newcsfvec )
```

## Augment CSF probability

```{r kmeanstemplate2,eval=TRUE}
plot( jlf$probimgs[[1]],dorot=1,window.img=c(0,4), slices=8 )
```

## Augment CSF probability

```{r kmeanstemplate3,eval=TRUE}
plot( newcsf,dorot=1,window.img=c(0,4), slices=8 )
```


## Renormalize probabilities

```{r renoprobs,eval=TRUE}
csfind=1
notcsfinds=2:length(jlf$probimgs)
jlfmat=imageListToMatrix( jlf$probimgs, mk )
prsums=colSums( jlfmat ) # i=26 for testing
for ( i in 1:ncol(jlfmat) ) {
  colvec=jlfmat[,i]
  notcsfsum=sum( colvec[notcsfinds] )
  csfval=newcsfvec[i]
  colvec[csfind]=csfval # the fix is in!
  if ( notcsfsum > 0 )
    colvec[notcsfinds]=colvec[notcsfinds]/notcsfsum*(1.0-csfval)
  else colvec[csfind]=1
  jlfmat[,i]=colvec
}
newprobimgs=matrixToImages( jlfmat, mk )
```

## Segment new images with these modified priors

We can use the template, itself, as an example.

Obviously, we skip the registration step.

```{r tempseg}
segnew <- atropos( d = 3, a = t1tem, m = '[0.05,1x1x1]',
   c = '[2,0]',  i = newprobimgs, x = mk )
```

A more complete process is available in `antsAtroposN4.sh` which 
is what we use for production.

We might go further and force the posteriors to be zero 
where the priors are zero ...

## Template and segmentation

```{r timg,echo=FALSE}
plot( t1tem , dorot = 1 , slices=8 )
```

## Template and *Atropos* segmentation

```{r timg2,echo=FALSE}
plot( t1tem, segnew$segmentation , dorot = 1 , slices=8 )
```

## Template and *JLF* segmentation

```{r timg3,echo=FALSE}
plot( t1tem, jlf$segimg , dorot = 1 , slices=8 )
```


